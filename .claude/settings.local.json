{
  "permissions": {
    "allow": [
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "WebFetch(domain:github.com)",
      "Bash(python3:*)",
      "Bash(GITHUB_TOKEN=\"dummy\" WORKFLOWS_DIR=\".\" python3 -c \"\nimport os\nimport re\nimport sys\nimport json\nimport yaml\nimport requests\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple, Set\n\nclass ActionAuditor:\n    def __init__(self, github_token: str):\n        self.github_token = github_token\n        self.headers = {\n            'Authorization': f'token {github_token}',\n            'Accept': 'application/vnd.github.v3+json',\n            'User-Agent': 'GitHub-Action-Security-Auditor/1.0'\n        }\n        self.verified_publishers = set()\n        self.action_references = []\n        self.issues = []\n        \n    def find_workflow_files(self, workflows_dir: str) -> List[str]:\n        \\\"\\\"\\\"Find all YAML workflow files.\\\"\\\"\\\"\n        workflow_files = []\n        workflows_path = Path(workflows_dir)\n        \n        if not workflows_path.exists():\n            print(f'Workflows directory not found: {workflows_dir}')\n            return []\n        \n        # Find all YAML files recursively\n        for pattern in ['*.yml', '*.yaml']:\n            workflow_files.extend(workflows_path.rglob(pattern))\n        \n        return [str(f) for f in workflow_files]\n    \n    def parse_workflow_file(self, file_path: str) -> None:\n        \\\"\\\"\\\"Parse a workflow file and extract action references.\\\"\\\"\\\"\n        try:\n            with open(file_path, 'r') as f:\n                content = f.read()\n            \n            # Parse YAML\n            try:\n                workflow = yaml.safe_load(content)\n            except yaml.YAMLError as e:\n                print(f'Warning: Could not parse YAML in {file_path}: {e}')\n                return\n            \n            # Extract action references using regex on raw content\n            uses_pattern = r'^\\s*uses:\\s*([\\'\\\"\\\"]*?)([^@\\s]+@[^\\'\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\"\\\\s]+)\\\\1\\\\s*$'\n            \n            lines = content.split('\\n')\n            for line_num, line in enumerate(lines, 1):\n                match = re.search(uses_pattern, line, re.MULTILINE)\n                if match:\n                    action_ref = match.group(2).strip()\n                    # Skip local actions (starting with ./)\n                    if not action_ref.startswith('./'):\n                        self.action_references.append({\n                            'file': file_path,\n                            'line': line_num,\n                            'action': action_ref,\n                            'raw_line': line.strip()\n                        })\n\n        except Exception as e:\n            print(f'Error parsing {file_path}: {e}')\n    \n    def is_commit_hash(self, version: str) -> bool:\n        \\\"\\\"\\\"Check if version is a commit hash (40-character hex string).\\\"\\\"\\\"\n        return bool(re.match(r'^[a-f0-9]{40}$', version))\n    \n    def check_verified_publisher(self, owner: str, action_name: str = None) -> bool:\n        \\\"\\\"\\\"Check if the action owner is a verified publisher by fetching marketplace page.\\\"\\\"\\\"\n        if owner in self.verified_publishers:\n            return True\n        \n        # Try multiple marketplace URL patterns\n        urls_to_try = []\n        \n        if action_name:\n            # Try action name first\n            urls_to_try.append(f'https://github.com/marketplace/actions/{action_name}')\n            # Try with owner prefix\n            urls_to_try.append(f'https://github.com/marketplace/actions/{owner}-{action_name}')\n        \n        # Try owner name\n        urls_to_try.append(f'https://github.com/marketplace/actions/{owner}')\n        \n        for marketplace_url in urls_to_try:\n            try:\n                print(f'Trying: {marketplace_url}')\n                # Fetch marketplace page\n                response = requests.get(marketplace_url, timeout=15)\n                \n                if response.status_code == 200:\n                    page_content = response.text\n                    \n                    # Check for verification elements\n                    is_verified = self._check_verification_elements(page_content, owner)\n                    \n                    # Cache the result\n                    if is_verified:\n                        self.verified_publishers.add(owner)\n                    \n                    return is_verified\n                elif response.status_code == 404:\n                    # Try next URL pattern\n                    continue\n                else:\n                    print(f'Warning: HTTP {response.status_code}')\n                    \n            except Exception as e:\n                print(f'Error: {e}')\n                continue\n        \n        return False\n    \n    def _check_verification_elements(self, page_content: str, owner: str) -> bool:\n        \\\"\\\"\\\"Check for verification elements in the marketplace page content.\\\"\\\"\\\"\n        # Check for \\\"Verified\\\" text\n        if 'Verified' not in page_content:\n            return False\n        \n        # Check for the specific verification text\n        verification_text = 'GitHub has manually verified the creator of the action as an official partner organization.'\n        if verification_text not in page_content:\n            return False\n        \n        # Check for organization link in the about section\n        # Look for various formats of GitHub links (case-insensitive)\n        owner_variants = [owner, owner.lower(), owner.upper(), owner.capitalize()]\n        \n        link_found = False\n        for owner_variant in owner_variants:\n            org_link_patterns = [\n                f'https://github.com/{owner_variant}',\n                f'/{owner_variant}',  # Relative link format\n                f'href=\\\"/{owner_variant}\\\"',  # HTML href format\n                f'[{owner_variant}](/{owner_variant})',  # Markdown link format\n                f'github.com/{owner_variant}',  # Without protocol\n            ]\n            \n            for pattern in org_link_patterns:\n                if pattern in page_content:\n                    link_found = True\n                    break\n            \n            if link_found:\n                break\n        \n        if not link_found:\n            return False\n        \n        return True\n\n# Test the implementation\nauditor = ActionAuditor('dummy')\n\n# Test bearer action\nprint('Testing bearer/bearer-action...')\nresult = auditor.check_verified_publisher('bearer', 'bearer-action')\nprint(f'Bearer verification result: {result}')\n\nprint()\n\n# Test actions/checkout \nprint('Testing actions/checkout...')\nresult = auditor.check_verified_publisher('actions', 'checkout')\nprint(f'Actions verification result: {result}')\n\")",
      "Bash(git tag:*)",
      "Bash(python test:*)",
      "Bash(rm:*)",
      "Bash(mkdir:*)",
      "Bash(git push:*)",
      "Bash(find:*)",
      "Bash(GITHUB_TOKEN=dummy-token WORKFLOWS_DIR=. WHITELIST=\"actions,docker\" BLACKLIST=\"suspicious,untrusted/repo\" python3 audit_actions.py)",
      "Bash(GITHUB_TOKEN=dummy-token WORKFLOWS_DIR=. WHITELIST='[\"actions\", \"docker\"]' BLACKLIST='[\"suspicious\", \"untrusted/repo\"]' python3 audit_actions.py)",
      "Bash(grep:*)"
    ],
    "deny": []
  }
}