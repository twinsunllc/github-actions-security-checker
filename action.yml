name: 'GitHub Actions Security Checker'
description: 'Checks GitHub Actions for security best practices: verified publishers and commit hash pinning'
author: 'Twin Sun LLC'
branding:
  icon: 'shield'
  color: 'green'
inputs:
  github_token:
    description: 'GitHub token for API access to check verified publishers'
    required: true
    default: ${{ github.token }}
  workflows_dir:
    description: 'Directory containing workflow files to audit'
    required: false
    default: '.github/workflows'
outputs:
  report:
    description: 'Security audit report in Markdown format'
    value: ${{ steps.audit.outputs.report }}
  exit_code:
    description: 'Exit code (0 for pass, 1 for fail)'
    value: ${{ steps.audit.outputs.exit_code }}
  passed:
    description: 'Boolean indicating if all checks passed'
    value: ${{ steps.audit.outputs.exit_code == '0' }}
runs:
  using: 'composite'
  steps:
    - name: Setup Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065  # v5
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      shell: bash
      run: |
        python -m pip install --upgrade pip
        pip install pyyaml requests
    
    - name: Run security audit
      id: audit
      shell: bash
      run: |
        set -e
        
        # Create audit script
        cat > audit_actions.py << 'EOF'
        #!/usr/bin/env python3
        import os
        import re
        import sys
        import json
        import yaml
        import requests
        from pathlib import Path
        from typing import Dict, List, Tuple, Set
        
        class ActionAuditor:
            def __init__(self, github_token: str):
                self.github_token = github_token
                self.headers = {
                    'Authorization': f'token {github_token}',
                    'Accept': 'application/vnd.github.v3+json',
                    'User-Agent': 'GitHub-Action-Security-Auditor/1.0'
                }
                self.verified_publishers = set()
                self.action_references = []
                self.issues = []
                
            def find_workflow_files(self, workflows_dir: str) -> List[str]:
                """Find all YAML workflow files."""
                workflow_files = []
                workflows_path = Path(workflows_dir)
                
                if not workflows_path.exists():
                    print(f"Workflows directory not found: {workflows_dir}")
                    return []
                
                # Find all YAML files recursively
                for pattern in ['*.yml', '*.yaml']:
                    workflow_files.extend(workflows_path.rglob(pattern))
                
                return [str(f) for f in workflow_files]
            
            def parse_workflow_file(self, file_path: str) -> None:
                """Parse a workflow file and extract action references."""
                try:
                    with open(file_path, 'r') as f:
                        content = f.read()
                    
                    # Parse YAML
                    try:
                        workflow = yaml.safe_load(content)
                    except yaml.YAMLError as e:
                        print(f"Warning: Could not parse YAML in {file_path}: {e}")
                        return
                    
                    # Extract action references using regex on raw content
                    # This catches actions in all contexts (jobs, steps, etc.)
                    uses_pattern = r'uses:\s*([\'"]?)([^@\s\'"\#]+@[^\s\'"\#]+)\1'
                    
                    lines = content.split('\n')
                    for line_num, line in enumerate(lines, 1):
                        match = re.search(uses_pattern, line, re.MULTILINE)
                        if match:
                            action_ref = match.group(2).strip()
                            # Skip local actions (starting with ./)
                            if not action_ref.startswith('./'):
                                self.action_references.append({
                                    'file': file_path,
                                    'line': line_num,
                                    'action': action_ref,
                                    'raw_line': line.strip()
                                })
                
                except Exception as e:
                    print(f"Error parsing {file_path}: {e}")
            
            def is_commit_hash(self, version: str) -> bool:
                """Check if version is a commit hash (40-character hex string)."""
                return bool(re.match(r'^[a-f0-9]{40}$', version))
            
            def check_verified_publisher(self, owner: str, action_name: str = None) -> bool:
                """Check if the action owner is a verified publisher by fetching marketplace page."""
                if owner in self.verified_publishers:
                    return True
                
                # Try multiple marketplace URL patterns
                urls_to_try = []
                
                if action_name:
                    # Try action name first
                    urls_to_try.append(f'https://github.com/marketplace/actions/{action_name}')
                    # Try with owner prefix
                    urls_to_try.append(f'https://github.com/marketplace/actions/{owner}-{action_name}')
                
                # Try owner name
                urls_to_try.append(f'https://github.com/marketplace/actions/{owner}')
                
                for marketplace_url in urls_to_try:
                    try:
                        # Fetch marketplace page
                        response = requests.get(marketplace_url, timeout=15)
                        
                        if response.status_code == 200:
                            page_content = response.text
                            
                            # Check for verification elements
                            is_verified = self._check_verification_elements(page_content, owner)
                            
                            # Cache the result
                            if is_verified:
                                self.verified_publishers.add(owner)
                            
                            return is_verified
                        elif response.status_code == 404:
                            # Try next URL pattern
                            continue
                        else:
                            print(f"Warning: Could not fetch marketplace page {marketplace_url}: HTTP {response.status_code}")
                            
                    except Exception as e:
                        print(f"Warning: Error checking marketplace {marketplace_url}: {e}")
                        continue
                
                return False
            
            def _check_verification_elements(self, page_content: str, owner: str) -> bool:
                """Check for verification elements in the marketplace page content."""
                # Check for "Verified" text
                if 'Verified' not in page_content:
                    return False
                
                # Check for the specific verification text
                verification_text = "GitHub has manually verified the creator of the action as an official partner organization."
                if verification_text not in page_content:
                    return False
                
                # Check for organization link in the about section
                # Look for various formats of GitHub links (case-insensitive)
                owner_variants = [owner, owner.lower(), owner.upper(), owner.capitalize()]
                
                link_found = False
                for owner_variant in owner_variants:
                    org_link_patterns = [
                        f'https://github.com/{owner_variant}',
                        f'/{owner_variant}',  # Relative link format
                        f'href="/{owner_variant}"',  # HTML href format
                        f'[{owner_variant}](/{owner_variant})',  # Markdown link format
                        f'github.com/{owner_variant}',  # Without protocol
                    ]
                    
                    for pattern in org_link_patterns:
                        if pattern in page_content:
                            link_found = True
                            break
                    
                    if link_found:
                        break
                
                if not link_found:
                    return False
                
                return True
            
            def audit_actions(self) -> Tuple[List[Dict], int]:
                """Audit all found actions."""
                report = []
                exit_code = 0
                
                print(f"\nüîç Found {len(self.action_references)} external action references\n")
                
                for ref in self.action_references:
                    action_full = ref['action']
                    file_path = ref['file']
                    line_num = ref['line']
                    
                    # Parse action owner/name and version
                    if '@' not in action_full:
                        continue
                        
                    action_path, version = action_full.rsplit('@', 1)
                    if '/' not in action_path:
                        continue
                        
                    owner = action_path.split('/')[0]
                    action_name = action_path.split('/')[1] if '/' in action_path else None
                    
                    # Check if commit hash
                    is_pinned_to_hash = self.is_commit_hash(version)
                    
                    # Check if verified publisher
                    is_verified = self.check_verified_publisher(owner, action_name)
                    
                    # Determine status
                    status = "‚úÖ PASS"
                    issues = []
                    
                    if not is_verified:
                        issues.append("Not from verified publisher")
                        status = "‚ùå FAIL"
                        exit_code = 1
                    
                    if not is_pinned_to_hash:
                        issues.append("Not pinned to commit hash")
                        status = "‚ùå FAIL"
                        exit_code = 1
                    
                    # Check for typos in common action names
                    if 'aws-action/' in action_path:  # Should be aws-actions
                        issues.append("Possible typo: 'aws-action' should be 'aws-actions'")
                        status = "‚ùå FAIL"
                        exit_code = 1
                    
                    # Strip the base path for cleaner output
                    display_path = file_path
                    for prefix in ['/home/runner/work/', '/github/workspace/', os.getcwd() + '/']:
                        if display_path.startswith(prefix):
                            display_path = display_path[len(prefix):]
                            break
                    
                    report_entry = {
                        'file': display_path,
                        'line': line_num,
                        'action': action_full,
                        'owner': owner,
                        'version': version,
                        'is_verified': is_verified,
                        'is_pinned_to_hash': is_pinned_to_hash,
                        'status': status,
                        'issues': issues
                    }
                    
                    report.append(report_entry)
                
                return report, exit_code
            
            def generate_report(self, report: List[Dict], exit_code: int) -> str:
                """Generate a formatted report."""
                output = []
                output.append("# GitHub Actions Security Audit Report")
                output.append("")
                
                if exit_code == 0:
                    output.append("## ‚úÖ All checks passed!")
                else:
                    output.append("## ‚ùå Security issues found!")
                
                output.append("")
                output.append(f"**Total actions audited:** {len(report)}")
                
                # Summary statistics
                verified_count = sum(1 for r in report if r['is_verified'])
                hash_pinned_count = sum(1 for r in report if r['is_pinned_to_hash'])
                failed_count = sum(1 for r in report if '‚ùå' in r['status'])
                
                output.append(f"**Verified publishers:** {verified_count}/{len(report)}")
                output.append(f"**Commit hash pinned:** {hash_pinned_count}/{len(report)}")
                output.append(f"**Failed checks:** {failed_count}")
                output.append("")
                
                # Detailed results
                output.append("## Detailed Results")
                output.append("")
                
                for entry in report:
                    output.append(f"### {entry['status']} {entry['action']}")
                    output.append(f"- **File:** {entry['file']}:{entry['line']}")
                    output.append(f"- **Owner:** {entry['owner']}")
                    output.append(f"- **Version:** {entry['version']}")
                    output.append(f"- **Verified Publisher:** {'‚úÖ' if entry['is_verified'] else '‚ùå'}")
                    output.append(f"- **Pinned to Hash:** {'‚úÖ' if entry['is_pinned_to_hash'] else '‚ùå'}")
                    
                    if entry['issues']:
                        output.append(f"- **Issues:** {', '.join(entry['issues'])}")
                    
                    output.append("")
                
                # Recommendations
                if exit_code != 0:
                    output.append("## üîß Recommendations")
                    output.append("")
                    output.append("1. **Pin to commit hashes:** Use specific commit SHA instead of tags")
                    output.append("2. **Use verified publishers:** Only use actions from trusted sources")
                    output.append("3. **Fix typos:** Correct action names to prevent supply chain attacks")
                    output.append("")
                    output.append("Example of secure action usage:")
                    output.append("```yaml")
                    output.append("- name: Checkout")
                    output.append("  uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11  # v4.1.1")
                    output.append("```")
                
                return "\n".join(output)
            
            def run_audit(self, workflows_dir: str) -> Tuple[str, int]:
                """Run the complete audit."""
                print("üîç Starting GitHub Actions security audit...")
                
                # Find workflow files
                workflow_files = self.find_workflow_files(workflows_dir)
                print(f"üìÅ Found {len(workflow_files)} workflow files")
                
                # Parse each file
                for file_path in workflow_files:
                    self.parse_workflow_file(file_path)
                
                # Audit actions
                report, exit_code = self.audit_actions()
                
                # Generate report
                report_text = self.generate_report(report, exit_code)
                
                return report_text, exit_code
        
        def main():
            github_token = os.environ.get('GITHUB_TOKEN', '')
            if not github_token:
                print("Error: GITHUB_TOKEN environment variable is required")
                sys.exit(1)
            
            workflows_dir = os.environ.get('WORKFLOWS_DIR', '.github/workflows')
            
            auditor = ActionAuditor(github_token)
            report, exit_code = auditor.run_audit(workflows_dir)
            
            print(report)
            
            # Save report to file
            with open('action-security-report.md', 'w') as f:
                f.write(report)
            
            # Set GitHub Actions outputs using new syntax
            with open(os.environ.get('GITHUB_OUTPUT', '/dev/null'), 'a') as f:
                f.write(f"report<<EOF\n{report}\nEOF\n")
                f.write(f"exit_code={exit_code}\n")
            
            sys.exit(exit_code)
        
        if __name__ == '__main__':
            main()
        EOF
        
        # Make script executable and run it
        chmod +x audit_actions.py
        python3 audit_actions.py
      env:
        GITHUB_TOKEN: ${{ inputs.github_token }}
        WORKFLOWS_DIR: ${{ inputs.workflows_dir }}